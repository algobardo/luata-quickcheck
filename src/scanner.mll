{
  (** Autogenerated scanner module *)

    module P = Parser     (* tokens are defined here *)
    
    exception Scan of string
    
    let error msg pos = Error.error "Scanner error" msg pos

    let get         = Lexing.lexeme
    let getchar     = Lexing.lexeme_char
    let strlen      = String.length
    let pos_start   = Lexing.lexeme_start
    let pos_end     = Lexing.lexeme_end

    let keywords    = Hashtbl.create 27
    let keyword s   = Hashtbl.find keywords s
    let _ = Array.iter (fun (str,tok) -> Hashtbl.add keywords str tok)
      [| ("and"         , P.AND)
      ;  ("break"       , P.BREAK)
      ;  ("case"        , P.CASE)
      ;  ("do"          , P.DO)
      ;  ("else"        , P.ELSE)
      ;  ("elseif"      , P.ELSEIF)
      ;  ("end"         , P.END)
      ;  ("for"         , P.FOR)
      ;  ("function"    , P.FUNCTION)
      ;  ("globmatch"   , P.GLOBMATCH)
      ;  ("goto"        , P.GOTO)
      ;  ("if"          , P.IF)
      ;  ("in"          , P.IN)
      ;  ("local"       , P.LOCAL)
      ;  ("nil"         , P.NIL)
      ;  ("true"        , P.TRUE)
      ;  ("false"       , P.FALSE)
      ;  ("not"         , P.NOT)
      ;  ("of"          , P.OF)
      ;  ("or"          , P.OR)
      ;  ("repeat"      , P.REPEAT)
      ;  ("return"      , P.RETURN)
      ;  ("then"        , P.THEN)
      ;  ("until"       , P.UNTIL)
      ;  ("while"       , P.WHILE) 
      |]

}

let digit       = ['0'-'9']
let alpha       = ['a'-'z' 'A'-'Z']
let misc        = ['_']

let sign        = ['+' '-']
let exp         = ['e''E'] sign? digit+

let hexdigit     = digit | ['a'-'f' 'A'-'F']

let INT          = digit+
let HEX	         = ("0x"|"0X") hexdigit+
let FLOAT_OR_EXP = (digit+ '.' digit* exp?)
                 | ('.' digit+ exp?)
                 | (digit+ exp)

let deccharcode  = ('\\' digit) | ('\\' digit digit) | ('\\' digit digit digit)
let hexcharcode  = "\\x" hexdigit hexdigit

let id          = (alpha | misc) (alpha | misc | digit)*
let ws          = [' ' '\t' '\r'] (* newline gets extra treatment! *)

let tab   = '\009'
let cr    = '\013'
let lf    = '\010'
let nl   = cr | lf | cr lf 

rule token = parse      (* raise Error in case of error *)
    eof         { P.EOF }
  | ws+         { token lexbuf }
  | nl          { Lexing.new_line lexbuf; token lexbuf }
  | id          { let s = get lexbuf in
                  try keyword s with Not_found -> P.NAME s
                }
  | INT          { let s = get lexbuf in P.NUMBER (Ast.Int (int_of_string s)) }
  | HEX          { let s = get lexbuf in P.NUMBER (Ast.Hex (int_of_string s)) }
  | FLOAT_OR_EXP { let s = get lexbuf in P.NUMBER (Ast.Float (float_of_string s)) }
  
  | ".."        { P.CONC  }
  | "..."       { P.DOTS  }
  | "<="        { P.LE    }
  | "=="        { P.EQ    }
  | "=>"        { P.ARROW }
  | ">="        { P.GE    }
  | "~="        { P.NE    }
  | '('         { P.LPAR  }
  | ')'         { P.RPAR  }
  | '*'         { P.STAR  }
  | '+'         { P.PLUS  }
  | ','         { P.COMMA }
  | '-'         { P.MINUS }
  | '.'         { P.DOT   }
  | '#'         { P.HASH  }
  | '/'         { P.SLASH }
  | '%'         { P.MOD   }
  | ':'         { P.COLON }
  | ';'         { P.SEMI  }
  | '<'         { P.LT    }
  | '='         { P.GETS  }
  | '>'         { P.GT    }
  | '['         { P.LSQ   }
  | ']'         { P.RSQ   }
  | '^'         { P.HAT   }
  | '{'         { P.LBRA  }
  | '}'         { P.RBRA  }

 (* this token is defined in the LUA lex.c file but is not used
  | '~'         { fun map ->  P.TILDE } *)

  | "--[" '='* '['               { let level = String.length (get lexbuf) - 4 in (* sans --[ [ *)
				   longcomment level lexbuf }
  | "--" nl                      { Lexing.new_line lexbuf; token lexbuf }
  | "--" [^ '[' '\n'] [^ '\n']*  { token lexbuf }
  | '\''         { shortstring lexbuf "'" (Buffer.create 80) }
  | '"'          { shortstring lexbuf "\"" (Buffer.create 80) }
  | '[' '='* '[' { let level = String.length (get lexbuf) - 2 in (* sans [ [ *)
		   longstring level lexbuf 1 (Buffer.create 160) }

  | _            { error "illegal character" lexbuf.Lexing.lex_start_p }

and longcomment level = parse
    eof          { error "end of file in long comment" lexbuf.Lexing.lex_start_p }
  | nl           { Lexing.new_line lexbuf; longcomment level lexbuf }
  | ']' '='* ']' { let exitlevel = String.length (get lexbuf) - 2 in (* sans ] ] *)
		   if level = exitlevel
		   then token lexbuf
		   else longcomment level lexbuf }
  | _            { longcomment level lexbuf }

and longstring level = parse  (* parse a [[ .. ]] string *)
    eof          { fun n buf -> error "end of file in long string" lexbuf.Lexing.lex_start_p }
  | ']' '='* ']' { fun n buf ->
                     let s = get lexbuf in
		     let exitlevel = String.length s - 2 in (* sans ] ] *)
		     if level = exitlevel
		     then P.LONGSTRING (Ast.Long (Buffer.contents buf))
		     else ( Buffer.add_string buf s;
			    longstring level lexbuf (n-1) buf) }
  | "[["         { fun n buf ->
                     ( Buffer.add_string buf "[["
                     ; longstring level lexbuf (n+1) buf
                     ) }
  | [^']' '[' '\n']+
  | ']' 
  | '['          { fun n buf -> 
                     let s = get lexbuf in
                     ( Buffer.add_string buf s
                     ; longstring level lexbuf n buf
                     ) }
  | nl           { fun n buf -> 
                     ( Buffer.add_char buf '\n'
                     ; Lexing.new_line lexbuf (*; nl lexbuf map*)
                     ; longstring level lexbuf n buf
                     ) }

and shortstring = parse (* parse an eos delimited string *)
    eof         { fun eos buf -> error "end of file in string" lexbuf.Lexing.lex_start_p } 
  | '\n'        { fun eos buf -> error "end of line in string" lexbuf.Lexing.lex_start_p }
  | hexcharcode { fun eos buf -> 
                  let s = get lexbuf in
                  let s = "0" ^ (String.sub s 1 3) in (*starting at 'x', finishing at the second hexdigit*)
		  let i = int_of_string s in (* now in OCaml's 0xhh format *)
		  (Buffer.add_char buf (Char.chr i);
		   shortstring lexbuf eos buf)
		}
  | deccharcode { fun eos buf -> 
                  let s = get lexbuf in
                  let s = String.sub s 1 (String.length s - 1) in
		  let i = int_of_string s in
		  if i <= 255
		  then
		    (Buffer.add_char buf (Char.chr i);
		     shortstring lexbuf eos buf)
		  else error "decimal escape too large" lexbuf.Lexing.lex_start_p
		}
  | '\\' _      { fun eos buf -> 
                  let c = getchar lexbuf 1 in
                  let k = match c with
                      | 'a'  -> '\007' (* '\a' *)
                      | 'b'  -> '\b'
                      | 'f'  -> '\012' (* '\f' *)
                      | 'n'  -> '\n'
                      | 'r'  -> '\r'
                      | 't'  -> '\t'
                      | 'v'  -> '\011' (* '\v' *)
                      | '\n' -> '\n'
                      | '\\' -> '\\'
                      | '\"' -> '\"'
                      | '\'' -> '\''
                      | _    -> error "illegal escape sequence in string" lexbuf.Lexing.lex_start_p
		  (*also handle: [ ]*)
                  in (Buffer.add_char buf k;
		      shortstring lexbuf eos buf)
                 }
  | [^'"' '\'' '\n' '\\']+  
                 { fun eos buf -> 
                   let s = get lexbuf  in
                     ( Buffer.add_string buf s
                     ; shortstring lexbuf eos buf
                     )
                 }
  | ['"' '\'' ]  { fun eos buf ->
                   let s = get lexbuf in
                      if s = eos then
			match s with
			  | "'" -> P.STRING (Ast.Char (Buffer.contents buf))
			  | _   -> P.STRING (Ast.Normal (Buffer.contents buf))
                      else
                        ( Buffer.add_string buf s
                        ; shortstring lexbuf eos buf
                        )
                  }
  | _             { fun eos buf -> assert false }


{
        let str2str s = match s with
	  | Ast.Normal s -> "\"" ^ s ^ "\""
	  | Ast.Char s   -> "'" ^ s ^ "'"
	  | Ast.Long s   -> "[[" ^ s ^ "]]"
        let tok2str = function
          | P.AND         -> "AND"
          | P.ARROW       -> "ARROW"
          | P.BREAK       -> "BREAK"
          | P.CASE        -> "CASE"
          | P.COLON       -> "COLON"
          | P.COMMA       -> "COMMA"
          | P.CONC        -> "CONC"
          | P.DEBUG_PRAGMA n-> "DEBUG_PRAGMA" ^ (string_of_int n)
          | P.DO          -> "DO"
          | P.DOT         -> "DOT"
          | P.DOTS        -> "DOTS"
          | P.ELSE        -> "ELSE"
          | P.ELSEIF      -> "ELSEIF"
          | P.END         -> "END"
          | P.EOF         -> "EOF"
          | P.EQ          -> "EQ"
          | P.FOR         -> "FOR"
          | P.FUNCTION    -> "FUNCTION"
          | P.GE          -> "GE"
          | P.GETS        -> "GETS"
          | P.GLOBMATCH   -> "GLOBMATCH"
          | P.GOTO        -> "GOTO"
          | P.GT          -> "GT"
          | P.HAT         -> "HAT"
          | P.IF          -> "IF"
          | P.IN          -> "IN"
          | P.LBRA        -> "LBRA"
          | P.LE          -> "LE"
          | P.LOCAL       -> "LOCAL"
          | P.LPAR        -> "LPAR"
          | P.LSQ         -> "LSQ"
          | P.LT          -> "LT"
          | P.MINUS       -> "MINUS"
          | P.NAME x      -> "NAME("^x^")"  
          | P.NE          -> "NE"
          | P.NIL         -> "NIL"
          | P.TRUE        -> "TRUE"
          | P.FALSE       -> "FALSE"
          | P.NOT         -> "NOT"
          | P.HASH        -> "HASH"
          | P.NUMBER _    -> "NUMBER" 
          | P.OF          -> "OF"
          | P.OR          -> "OR"
          | P.PLUS        -> "PLUS"
          | P.RBRA        -> "RBRA"
          | P.REPEAT      -> "REPEAT"
          | P.RETURN      -> "RETURN"
          | P.RPAR        -> "RPAR"
          | P.RSQ         -> "RSQ"
          | P.SEMI        -> "SEMI"
          | P.SLASH       -> "SLASH"
          | P.MOD         -> "MOD"
          | P.STAR        -> "STAR"
          | P.STRING x    -> "STRING("^(str2str x)^")" 
          | P.LONGSTRING x -> "LONGSTRING("^(str2str x)^")" 
          | P.THEN        -> "THEN"
          | P.UNARY       -> "UNARY"
          | P.UNTIL       -> "UNTIL"
          | P.WHILE       -> "WHILE"
          | P.WRONGTOKEN  -> "WRONGTOKEN"
    }          
